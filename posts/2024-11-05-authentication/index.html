<!DOCTYPE html><html lang="en"><head><title>Shawn Casey - Senior iOS Engineer</title><meta name="twitter:title" content="Shawn Casey - Senior iOS Engineer"/><meta name="og:title" content="Shawn Casey - Senior iOS Engineer"/><meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/pure-min.css" integrity="sha384-oAOxQR6DkCoMliIh8yFnu25d7Eq/PHS21PClpwjOTeU2jRSq11vu66rf90/cZr47" crossorigin="anonymous"/><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/grids-responsive-min.css"/><link rel="stylesheet" href="/Pure/styles.css"/><link rel="stylesheet" href="/all.css"/></head><body><div id="layout" class="pure-g"><div><div class="pure-menu pure-menu-horizontal pure-u-1-1 top-header"><a class="pure-menu-heading" href="/">Swift Tech</a><ul class="pure-menu-list"><li class="pure-menu-item"><a class="pure-menu-link" href="/about">About</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/archive">Portfolio</a></li></ul></div></div><div class="sidebar pure-u-1 pure-u-md-1-4"><div class="header"><div id="layout" class="pure-g"><div class="author__avatar"><img src="https://avatars.githubusercontent.com/u/1760855?v=4"/></div><div class="pure-u-md-1-1 pure-u-3-4"><h1 class="brand-title">Shawn Casey</h1><h3 class="brand-tagline">Senior iOS Engineer</h3></div></div><div id="layout" class="pure-g"><div class="pure-u-md-1-1"><a href="https://en.wikipedia.org/wiki/Plano,_Texas"><i class="fas fa-map-marker-alt l-box social-icon"></i><a class="social-media" href="https://en.wikipedia.org/wiki/Plano,_Texas">Plano, TX USA</a></a></div><div class="pure-u-md-1-1"><a href="mailto:shawn.casey@gmail.com"><i class="fas fa-envelope-open-text l-box social-icon"></i><a class="social-media" href="mailto:shawn.casey@gmail.com">Email</a></a></div><div class="pure-u-md-1-1"><a href="https://www.linkedin.com/in/shawn-casey-9461504/"><i class="fab fa-linkedin l-box social-icon"></i><a class="social-media" href="https://www.linkedin.com/in/shawn-casey-9461504/">LinkedIn</a></a></div><div class="pure-u-md-1-1"><a href="https://github.com/shawnkc"><i class="fab fa-github-square l-box social-icon"></i><a class="social-media" href="https://github.com/shawnkc">GitHub</a></a></div></div></div></div><div class="content pure-u-1 pure-u-md-3-5 pure-u-xl-6-10"><h2 class="post-title"><a href="/posts/2024-11-05-authentication">Authentication Strategies</a></h2><p class="post-meta">November 5, 2024</p><div class="post-tags"><a class="post-category post-category-article" href="/tags/article">article</a><a class="post-category post-category-web" href="/tags/web">web</a><a class="post-category post-category-swift" href="/tags/swift">swift</a><a class="post-category post-category-server-side-swift" href="/tags/serversideswift">server-side-swift</a><a class="post-category post-category-vapor" href="/tags/vapor">vapor</a></div><div class="post-description"><div><h1>Authentication Strategies</h1><p>Authentication/Authorization strategies over the last couple of decades have changed quite a bit. It can be a deep topic as depending on your needs, the level of security varies drastically. It can also vary just due to the type of APIs/resources requested.</p><p>Firstly, lets talk about the difference between authentication and authorization.</p><ul><li><strong>Authentication</strong> - Authentication can be thought of as the ability to ensure the user is who he says he is.</li><li><strong>Authorization</strong> - Authorization is the process of ensuring proper access to resources based on the user.</li></ul><p>Authentication is the first step in connecting to a secure backend. Once authenticated, authorization is what determines the rights the user has to access various resources. Think of authorization as a way to grant different roles to a user such as admin, editor, or user.</p><h2>Authentication</h2><h3>Signup v. Signin</h3><p>If a user doesn't exist in the backend system, signing up is what is needed. So how do we create a user in the system. There are various methods of identity that can be used:</p><p><strong>Identity-based:</strong></p><ul><li>E-mail (most traditional)</li><li>Phone number</li></ul><p><strong>Token-based:</strong></p><blockquote><p><strong>TODO:</strong> what else? How do token techs like sign in with Apple work? How does 2FA work?</p></blockquote><p>Supporting signup can be done with built-in authentication technologies like "sign in with Google, Apple, Facebook".</p><p>After a user exists in the system, we need a way to sign in. If not using token-based auth, we need to send a an identity/password in a secure way. At a minimum, you secure the transport via SSL/TLS to avoid snooping over the wire. For an even more secure transport, you can pin SSL certs to ensure even the user can't snoop on themselves to perhaps learn how to exploit your strategy.</p><h3>Authentication Strategies</h3><ul><li>Basic auth</li><li>Session/Bearer Token</li><li>JWT</li><li>Oauth</li><li>Oauth2</li></ul><p>What are JWTs?</p><h3>Server Considerations</h3><p><strong>Identity-based</strong></p><p>With identity-based authentication, your server needs a way to be able to send emails or texts.</p><p>For email, here are some ways to send emails from the server:</p><ul><li>built in SMTP</li><li>SendGrip</li><li>Mailgun</li></ul><p>In Vapor:</p><pre><code><span class="keyword">import</span> SMTP

app.<span class="property">smtp</span>.<span class="property">configuration</span> = <span class="keyword">try</span> .<span class="keyword">init</span>(
    hostname: <span class="string">"smtp.mailtrap.io"</span>,
    port: <span class="number">465</span>,
    email: <span class="string">"your-email@example.com"</span>,
    password: <span class="string">"your-password"</span>
)
app.<span class="property">smtp</span>.<span class="property">defaultMailer</span> = .<span class="dotAccess">default</span>
</code></pre><p>For SMS, there is really only Twilio:</p><pre><code>app.<span class="call">post</span>(<span class="string">"sendEmail"</span>) { req -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">String</span>&gt; <span class="keyword">in
    let</span> email = <span class="type">Email</span>(
        from: <span class="type">EmailAddress</span>(address: <span class="string">"from@example.com"</span>, displayName: <span class="string">"Sender"</span>),
        to: [<span class="type">EmailAddress</span>(address: <span class="string">"to@example.com"</span>, displayName: <span class="string">"Recipient"</span>)],
        subject: <span class="string">"Your Verification Code"</span>,
        text: <span class="string">"Your verification code is: 123456"</span>
    )

    <span class="keyword">return</span> req.<span class="property">smtp</span>.<span class="call">send</span>(email)
        .<span class="call">transform</span>(to: <span class="string">"Email sent successfully"</span>)
}
</code></pre><p>A session ID, bearer token is returned in the response and then used on all subsequent requests.</p><h4>Security</h4><p>JWTs don't add any additional security for interception of the token. If the token is intercepted, it can be used to replay authentication for the user. Mitigation strategies for interception are using transport layer security such as SSL with perhaps SSL-pinning.</p><p>In terms of the response from authentication and what the client uses as an authentication key for all other Application server requests, there is no difference from a security perspective than a combination of a session ID/bearer token and handling 401 errors due to expired sessions.</p><p>JWTs are normally issued with a refresh token. JWTs can have a short lifespan which forces the client to refresh it periodically with the refresh token. The refresh token is stored in a more secure way on the client than a normal JWT so the turn around time that a JWT can be intercepted and used in a malevolent way can be minimized.</p><p><strong>Token-based</strong></p><p>With token-based authentication, your server doesn't have to send emails or texts, but it does need to be able to communicate with other servers in a backend peer-to-peer way.</p><h2>Authorization</h2><h3>Server Organization</h3><p>Authorization strategies depend on authentication strategy. You can get away with not storing session data if a JWT strategy is deployed. However, if a session/bearer token strategy is used, the Authorization server will need to create a session ID or bearer token that the client will then send with every request so that the client's identity tokens (username/password) aren't sent with every request. Instead, a simple ID is sent with every request and then the application server uses that ID to look up access rights including session timeouts to resources.</p><h4>JWT-based Solution</h4><p>Authentication server can be decoupled from Application server.</p><p>If Authentication server separated, a JWT can be used to encrypt authorization status and session information that gives access to the Application server. The Application server and the Authentication server both have access to a shared private key that is used to decrypt a JWT. The user will send the JWT with every request to the Application server and it decrypts the token, then knowing what resources are available to the user.</p><p>Roles are application specific and must be known by both the Authentication and Application servers. During authentication, the user's role is added to a JWT</p><h2>Vapor Implementation</h2><p>Now that we understand the theory a bit more, how can we put this together in <a href="https://vapor.codes">Vapor</a>?</p></div></div></div><div class="footer pure-u-1"><div class="pure-u-1">Â© 2024 Shawn Casey</div><div class="pure-u-1">Generated using <a href="https://github.com/johnsundell/publish">Publish</a></div><div class="pure-u-1"><a href="/feed.rss">RSS feed</a></div></div></div></body></html>