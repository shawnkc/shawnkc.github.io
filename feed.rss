<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Swift Dev Diary</title><description>New diary of an old developer</description><link>https://shawnkc.github.io</link><language>en</language><lastBuildDate>Wed, 6 Nov 2024 09:51:55 -0600</lastBuildDate><pubDate>Wed, 6 Nov 2024 09:51:55 -0600</pubDate><ttl>250</ttl><atom:link href="https://shawnkc.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://shawnkc.github.io/posts/2024-11-06-deployment</guid><title>Deployment Strategies</title><description>Deployment Strategies for Server-Side Swift</description><link>https://shawnkc.github.io/posts/2024-11-06-deployment</link><pubDate>Wed, 6 Nov 2024 09:35:00 -0600</pubDate><content:encoded><![CDATA[<h1>Deployment Strategies</h1><ul><li>Use docker locally</li></ul><h2>Hosting Services</h2><ul><li>Swift Cloud - HTTP/3, global deployments, serverless architecture</li><li>AWS Fargate - serverless compute engine that integrates with Vapor</li><li>Heroku</li><li>DigitalOcean</li><li>Vapor Cloud</li></ul><h3>Email providers</h3><p>When developing applications that require sending authentication codes via email, several services offer free tiers suitable for low-volume usage:</p><ol><li><strong>Mailtrap</strong>: Designed for safe email testing, Mailtrap’s free plan allows sending up to 1,000 emails per month. It’s ideal for development environments to ensure emails are correctly formatted and delivered.</li><li><strong>SendPulse</strong>: Offers a free plan that permits sending up to 12,000 emails per month, with a daily limit of 100 emails. This is beneficial for testing authentication emails during development.</li><li><strong>Brevo (formerly Sendinblue)</strong>: Provides a free plan allowing up to 300 emails per day, totaling approximately 9,000 emails per month. This service is suitable for development and small-scale production needs.</li><li><strong>Mailjet</strong>: Their free tier supports sending up to 200 emails per day, which is adequate for development purposes.</li><li><strong>MailerSend</strong>: Offers a free plan with up to 3,000 emails per month, providing a generous allowance for development and testing.</li></ol><p>These services provide free tiers that are well-suited for development environments, allowing you to send authentication codes without incurring costs, provided you stay within the specified limits.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://shawnkc.github.io/posts/2024-11-05-authentication</guid><title>Authentication Strategies</title><description>A deeper dive into authentication and authorization technologies and strategies.</description><link>https://shawnkc.github.io/posts/2024-11-05-authentication</link><pubDate>Tue, 5 Nov 2024 08:59:00 -0600</pubDate><content:encoded><![CDATA[<h1>Authentication Strategies</h1><p>Authentication/Authorization strategies over the last couple of decades have changed quite a bit. It can be a deep topic as depending on your needs, the level of security varies drastically. It can also vary just due to the type of APIs/resources requested.</p><p>Firstly, lets talk about the difference between authentication and authorization.</p><ul><li><strong>Authentication</strong> - Authentication can be thought of as the ability to ensure the user is who he says he is.</li><li><strong>Authorization</strong> - Authorization is the process of ensuring proper access to resources based on the user.</li></ul><p>Authentication is the first step in connecting to a secure backend. Once authenticated, authorization is what determines the rights the user has to access various resources. Think of authorization as a way to grant different roles to a user such as admin, editor, or user.</p><h2>Authentication</h2><h3>Signup v. Signin</h3><p>If a user doesn't exist in the backend system, signing up is what is needed. So how do we create a user in the system. There are various methods of identity that can be used:</p><p><strong>Identity-based:</strong></p><ul><li>E-mail (most traditional)</li><li>Phone number</li></ul><p><strong>Token-based:</strong></p><blockquote><p><strong>TODO:</strong> what else? How do token techs like sign in with Apple work? How does 2FA work?</p></blockquote><p>Supporting signup can be done with built-in authentication technologies like "sign in with Google, Apple, Facebook".</p><p>After a user exists in the system, we need a way to sign in. If not using token-based auth, we need to send a an identity/password in a secure way. At a minimum, you secure the transport via SSL/TLS to avoid snooping over the wire. For an even more secure transport, you can pin SSL certs to ensure even the user can't snoop on themselves to perhaps learn how to exploit your strategy.</p><h3>Authentication Strategies</h3><ul><li>Basic auth</li><li>Session/Bearer Token</li><li>JWT</li><li>Oauth</li><li>Oauth2</li></ul><p>What are JWTs?</p><h3>Server Considerations</h3><p><strong>Identity-based</strong></p><p>With identity-based authentication, your server needs a way to be able to send emails or texts.</p><p>For email, here are some ways to send emails from the server:</p><ul><li>built in SMTP</li><li>SendGrip</li><li>Mailgun</li></ul><p>In Vapor:</p><pre><code><span class="keyword">import</span> SMTP

app.<span class="property">smtp</span>.<span class="property">configuration</span> = <span class="keyword">try</span> .<span class="keyword">init</span>(
    hostname: <span class="string">"smtp.mailtrap.io"</span>,
    port: <span class="number">465</span>,
    email: <span class="string">"your-email@example.com"</span>,
    password: <span class="string">"your-password"</span>
)
app.<span class="property">smtp</span>.<span class="property">defaultMailer</span> = .<span class="dotAccess">default</span>
</code></pre><p>For SMS, there is really only Twilio:</p><pre><code>app.<span class="call">post</span>(<span class="string">"sendEmail"</span>) { req -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">String</span>&gt; <span class="keyword">in
    let</span> email = <span class="type">Email</span>(
        from: <span class="type">EmailAddress</span>(address: <span class="string">"from@example.com"</span>, displayName: <span class="string">"Sender"</span>),
        to: [<span class="type">EmailAddress</span>(address: <span class="string">"to@example.com"</span>, displayName: <span class="string">"Recipient"</span>)],
        subject: <span class="string">"Your Verification Code"</span>,
        text: <span class="string">"Your verification code is: 123456"</span>
    )

    <span class="keyword">return</span> req.<span class="property">smtp</span>.<span class="call">send</span>(email)
        .<span class="call">transform</span>(to: <span class="string">"Email sent successfully"</span>)
}
</code></pre><p>A session ID, bearer token is returned in the response and then used on all subsequent requests.</p><h4>Security</h4><p>JWTs don't add any additional security for interception of the token. If the token is intercepted, it can be used to replay authentication for the user. Mitigation strategies for interception are using transport layer security such as SSL with perhaps SSL-pinning.</p><p>In terms of the response from authentication and what the client uses as an authentication key for all other Application server requests, there is no difference from a security perspective than a combination of a session ID/bearer token and handling 401 errors due to expired sessions.</p><p>JWTs are normally issued with a refresh token. JWTs can have a short lifespan which forces the client to refresh it periodically with the refresh token. The refresh token is stored in a more secure way on the client than a normal JWT so the turn around time that a JWT can be intercepted and used in a malevolent way can be minimized.</p><p><strong>Token-based</strong></p><p>With token-based authentication, your server doesn't have to send emails or texts, but it does need to be able to communicate with other servers in a backend peer-to-peer way.</p><h2>Authorization</h2><h3>Server Organization</h3><p>Authorization strategies depend on authentication strategy. You can get away with not storing session data if a JWT strategy is deployed. However, if a session/bearer token strategy is used, the Authorization server will need to create a session ID or bearer token that the client will then send with every request so that the client's identity tokens (username/password) aren't sent with every request. Instead, a simple ID is sent with every request and then the application server uses that ID to look up access rights including session timeouts to resources.</p><h4>JWT-based Solution</h4><p>Authentication server can be decoupled from Application server.</p><p>If Authentication server separated, a JWT can be used to encrypt authorization status and session information that gives access to the Application server. The Application server and the Authentication server both have access to a shared private key that is used to decrypt a JWT. The user will send the JWT with every request to the Application server and it decrypts the token, then knowing what resources are available to the user.</p><p>Roles are application specific and must be known by both the Authentication and Application servers. During authentication, the user's role is added to a JWT</p><h2>Vapor Implementation</h2><p>Now that we understand the theory a bit more, how can we put this together in <a href="https://vapor.codes">Vapor</a>?</p>]]></content:encoded></item><item><guid isPermaLink="true">https://shawnkc.github.io/posts/2024-11-05-http-methods</guid><title>What are the HTTP Methods?</title><description>A quick overview of the various HTTP methods and their usage.</description><link>https://shawnkc.github.io/posts/2024-11-05-http-methods</link><pubDate>Tue, 5 Nov 2024 08:46:00 -0600</pubDate><content:encoded><![CDATA[<h1>What are the HTTP Methods?</h1><p>There are 5 main HTTP methods that are used to perform all CRUD (create, read, update, delete) operations on the backend.</p><ul><li><code>GET</code> - retrieves a target resource, usually with query parameters</li><li><code>POST</code> - creates a new resource, usually with a request body</li><li><code>PUT</code> - replaces a target resource with a new one</li><li><code>PATCH</code> - updates a target resource</li><li><code>DELETE</code> - deletes a target resource</li></ul><p>I've used all but PUT in production code. Most APIs I've worked with are either GET or POST-based APIs as replace/update operations can be done via POST methods.</p><p>Other HTTP methods I've never used before:</p><ul><li><code>HEAD</code> - asks for a resource like <code>GET</code>, but without a response body</li><li><code>CONNECT</code> - establishes a tunnel to the server identified by the target resource</li><li><code>OPTIONS</code> - describes the communication options for the target resource</li><li><code>TRACE</code> - performs a message loop-back test along the path to the target resource</li></ul><p>From: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">MDN web docs</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://shawnkc.github.io/posts/2020-03-23-first-post</guid><title>Using Publish and Github to Make a Website</title><description>We take a dive into using Publish and Github to setup a website and get our first blog post online!</description><link>https://shawnkc.github.io/posts/2020-03-23-first-post</link><pubDate>Mon, 23 Mar 2020 11:14:00 -0500</pubDate><content:encoded><![CDATA[<h1>Using Publish and Github to Make a Website</h1><p>Used https://github.com/JohnSundell/Publish to generate a website.</p><p>Not sure exactly how to use it yet but thought I'd just go ahead and make a 1% improvement.</p><p>More things yet to do:</p><ul><li>Figure out how to automatically deploy to github</li><li>Use code blocks</li><li>Define some colors on custom theme</li></ul><p>Thank you John Sundell and github for making this so easy!</p><p>Publish use:</p><ul><li><a href="https://github.com/JohnSundell/Ink">Ink</a> (Markdown parser)</li><li><a href="https://github.com/JohnSundell/Plot">Plot</a> (DSL for writing type-safe HTML in Swift)</li><li><a href="https://github.com/JohnSundell/Publish">Publish</a> (Static site-generator)</li></ul><p>Follow the instructions from the <a href="https://github.com/JohnSundell/Publish">Publish</a> github's README on how to get and setup your first website.</p><h2>Deploying to your github pages</h2><p>Used all the defaults from the new site published:</p><pre><code><span class="keyword">try</span> <span class="type">Websitedef</span>().<span class="call">publish</span>(
    withTheme: .<span class="dotAccess">foundation</span>,
    deployedUsing: .<span class="call">gitHub</span>(<span class="string">"shawnkc/shawnkc.github.io"</span>)
)
</code></pre><h2>New sections</h2><p>To create sections, open up <strong>main.swift</strong>, and within the <code>SectionID</code> enum, add all the sections you want.</p><pre><code><span class="keyword">enum</span> SectionID: <span class="type">String</span>, <span class="type">WebsiteSectionID</span> {
	<span class="comment">// Add the sections that you want your website to contain here:</span>
	<span class="keyword">case</span> posts
	<span class="keyword">case</span> about
}
</code></pre><figure>
    <img class="medium-image" src="../../images/2020-03-23-website-1.png" alt="" />
</figure><p>This shows the posts and about sections on the webpage.</p><p>To add a new static page, add a new item in the section ID enum and then create a single markdown file in the Content folder. For instance, to add a section for <strong>Links</strong>:</p><pre><code><span class="keyword">enum</span> SectionID: <span class="type">String</span>, <span class="type">WebsiteSectionID</span> {
	<span class="comment">// Add the sections that you want your website to contain here:</span>
	<span class="keyword">case</span> posts
	<span class="keyword">case</span> about
	<span class="keyword">case</span> links
}
</code></pre><figure>
    <img class="medium-image" src="../../images/2020-03-23-website-2.png" alt="" />
</figure><h2>Generation</h2><pre><code>$ website-def&gt; publish generate
</code></pre><p>Check the README.md for more details on the structure, generation and testing of the website.</p>]]></content:encoded></item></channel></rss>